---
title: Lecture 13 - Dynamic programming II
placeholder: false
back-color: fffffa
card-link: LecLink13
# subtitle: And a subtitle
description: We will continue our discussion of dynamic programming with the edit-distance and common subsequence problem(s). We'll also discuss the general formula for dynamic programming problems. 
people:
  - nicholas
layout: lecture
# no-link: true  # stops link to page 
deliverydate: 2025-06-25
link-slides: /materials/lecture_slides/lec13.pdf
link-scribbles: /materials/lecture_slides/lec13_scribbles_fa24.pdf
link-recording: https://mediaspace.illinois.edu/media/t/1_vbxpmhcw
pre-recording: https://youtube.com/playlist?list=PLmCFrqjQFNr0V_0fW_VuOyI-_cYTdJ3V4&si=e1ewU5YjmPZNhF8m
---

### Dynamic Programming
#### **Steps**:
1. Develop a recursive backtracking style algorithm, $A$, for the given problem

2. Identify the structure of the subproblems generated by $A$ on an instance, $I$, of size $n$
- Estimate the number of different subproblems as a function of $n$ (i.e. polynomial, exponential, etc)
- If the number of subproblems is small (polynomial) then there is typically a "clean" structure

3. Rewrite the subproblems in a compact fashion

4. Rewrite the recursive algorithm in terms of notation for subproblems

5. Convert $A$ to an iterative algorithm by bottom up evaluation in an appropriate order

6. Optimize further with data structures and/or additional ideas


#### **Problem 1: Minimum Alignment**

*Background:* An Alignment between two strings $X$ and $Y$ is placing one word on top of another word with potential gaps in between letters. Gaps in the first word indicate letter insertions, gaps in the second word indicate letter deletions.

<img src="/img/lectures/Lec14/lec14_fig1.PNG" alt="Example3" style="height: 50px;">
 
*Problem Statement:* For each mismatch in our alignment, for some $p$ and $q$ in the alphabet, we have a Mismatch Cost $\alpha_{pq}$. For each gap in our alignment we have a Gap Cost $\delta$. Given two words $X$ and $Y$ of sizes $m$ and $n$ respectively, find the alignment with the smallest cost.

1. The recursive backtracking algorithm is $Opt(i,j)$, the smallest alignment cost between strings $x_1 ... x_i$ and $y_1 ... y_j$. We can either insert, delete, or mismatch the last letter in the strings, the minimum alignment is the minimum of these options plus the minimum of the remaining alignment. This yields the following recurrence 

<img src="/img/lectures/Lec14/lec14_ex1_rec.PNG" alt="Example3" style="height: 150px;">

2. Each subproblem reduces the size of $X$ and/or $Y$ by 1, this means we will have at most $O(mn)$ different subproblems.

3. -5. This means the recursive backtracking algorithm can be implemented by filling out an array size $m+1$x$n+1$ by initializing the base cases and computing new array elements by the minimum between previously computed elements. 

```
EDIST(A[1..m],B[1..n])
  int M[0..m][0..n]
  for i ← 1 to m
     M[i][0] ← i*δ
  for j ← 1 to n
     M[0][j] ← j*δ
  for i ← 1 to m
     for j ← 1 to n
        M[i][j] ← min{COST[A[i]][B[j]]+M[i-1][j-1],δ+M[i-1][j],δ+M[i][j-1]}
  return M[m][n]
```

Running time is $O(mn)$. Space used is $O(mn)$.

6. When  computing an array element, the algorithm only uses the current and previous column (or row). Therefore we can store only the current and previous column (or row). Adding this change in results in space used being $O(\min(m,n))$. 



#### **Problem 2: Longest Common Subsequence**

*Problem Statement:* Find the longest common subsequence between two strings, $X$ and $Y$.

1. The recursive backtracking algorithm is $LCS(i,j)$, the longest common subsequence between strings $x_1 ... x_i$ and $y_1 ... y_j$. We can either choose to skip the last letter of $X$, skip the last letter of $Y$ or, if the last letters are the same, include the letters in the subsequence. This yields the following recurrence 

<img src="/img/lectures/Lec14/lec14_ex2_rec.PNG" alt="Example3" style="height: 165px;">

2. Each subproblem reduces the size of $X$ and/or $Y$ by 1, this means we will have at most $O(mn)$ different subproblems.

3. -5. This means the recursive backtracking algorithm can be implemented by filling out an array size $m+1$x$n+1$ by initializing the base cases and computing new array elements by the minimum between previously computed elements. 

```
LCS(A[1..m],B[1..n])
  int M[0..m][0..n]
  for i ← 1 to m
     M[i][0] ← 0
  for j ← 1 to n
     M[0][j] ← 0
  for i ← 1 to m
     for j ← 1 to n
        K ← max{M[i-1][j],M[i][j-1]}
        M[i][j] ← K
        if A[i]=B[j]
           M[i][j] ← max{K,1+M[i-1][j-1]}
  return M[m][n]
```

Running time is $O(mn)$. Space used is $O(mn)$.

6. This problem can be formulated as the problem in example 1. Set the Mismatch Cost for two different letters is set to $+\infty$ and set to $1$ for two identical letters. Set the Gap Cost to $1$. The result is that the alignment will never mismatch two different letters so the longest common subsequence is the minimum alignment cost minus the number of gaps. 


<h4> Even more DP problems! </h4>

Our very own Hamza Husain has dedicated himself to giving you even more DP problems for practice: 
- [Extra DP Lab Questions](/materials/extra_content/lab12-new.pdf)
- [Extra DP Lab Solutions](/materials/extra_content/lab12-sol-new.pdf)

<h4>Additional Resources</h4>

* Textbooks 
  * Erickson, Jeff. *Algorithms* 
	* [Chapter 3 - Dynamic Programming](https://jeffe.cs.illinois.edu/teaching/algorithms/book/03-dynprog.pdf)
  * Skiena, Steven. *The Algorithms Design Manual*
    * Chapter 10.2 - Approximate String Matching
  * Sedgewick, Robert and Wayne, Kevin. *Algorithms (Forth Edition)*
    * Chapter 6 - Suffix Arrays
  * Cormen, Thomas, et al. *Algorithms (Forth Edition)*
    * Chapter 14 - Dynamic Programming 
    * Chapter 14.4 - Longest Common Subsequence 
* [Sariel's Lecture 14](https://www.youtube.com/watch?v=o4gOGiBXT2g&list=PLaEwgrahG-Lq_ux1_o3TqFX-vWXh0uLLK&pp=iAQB) 
* Edit distance is also referred to as [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance)
    * Closely related is the [Needleman-Wunsch Algorithm](https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm)






